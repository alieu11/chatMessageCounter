# -*- coding: utf-8 -*-
"""ForteahouseMessageCounter.ipynb

Automatically generated by Colaboratory.

"""

import json
import matplotlib.pyplot as plt
import re

# open all the messages

with open('/content/message_1.json') as x:
  m1 = json.loads(x.read())
with open('/content/message_2.json') as x:
  m2 = json.loads(x.read())
with open('/content/message_3.json') as x:
  m3 = json.loads(x.read())
with open('/content/message_4.json') as x:
  m4 = json.loads(x.read())
with open('/content/message_5.json') as x:
  m5 = json.loads(x.read())
with open('/content/message_6.json') as x:
  m6 = json.loads(x.read())
with open('/content/message_7.json') as x:
  m7 = json.loads(x.read())

# make an array to hold all the messages
allMessages = [m1, m2, m3, m4, m5, m6, m7]

# for each particpant, count their messages
def messageCounter():
  """
  NOTE:

  The reason the code is not O(n) is because it chooses the participant first, 
  THEN searches the entire list of messages for the respective sender.
  For O(n), the code should parse through the messages, 
  and for each sender name, iterate the counter.

  Example: 
  message1 has sender1, so add 1 to sender1 counter
  message2 has sender2, so add 1 to sender2 counter
  message3 has sender1, so add 1 to sender1 counter

  This allows for the messages to be read through once, 
  instead of (number of participants) times. This would also allow for
  the possibility of a "timelapse".

  TODO:

  Make this program run in O(n)

  """

  # initialize empty dictionary
  unsortedDict = dict()

  # load all the participants, initialize count = 0
  for i in m1['participants']:
    count = 0

    # go through all the messages
    for j in allMessages:
      # for each message, if sender name matches the participant name, increment count by 1
      for k in j['messages']:
        if k['sender_name'] == i['name']:
          count = count + 1
    #print(i['name'], count)
    # add the name and respective count value to the unsorted dictionary
    tempName = i['name']
    unsortedDict[tempName] = count

    # sort the dictionary

  # sorts the dictionary by increasing messages
  sortedDict = dict(sorted(unsortedDict.items(), key = lambda item: item[1]))
  # print(sortedDict)

  return sortedDict

# for each person, count how many total words were spoken by them
def totalWordsSpoken():
  # initialize empty dictionary
  unsortedDict = dict()

  # load all the participants, initialize count = 0
  for i in m1['participants']:
    count = 0

  # go through all the messages
    for j in allMessages:
      # for each message, if sender name matches the participant name, increment count by 1
      for k in j['messages']:
        if k['sender_name'] == i['name']:
          if 'content' in k:
            #print(k['content'])
            r = re.findall(r'\w+', k['content'])
            count = count + len(r)
    #print(i['name'], count)
    # add the name and respective count value to the unsorted dictionary
    tempName = i['name']
    unsortedDict[tempName] = count

  # sort the dictionary

  # sorts the dictionary by increasing messages
  sortedDict = dict(sorted(unsortedDict.items(), key = lambda item: item[1]))
  # print(sortedDict)

  for keys, values in sortedDict.items():
    print(keys, values)

  return sortedDict


# for each person, count how many times a word was spoken
def wordCounter(word):

  unsortedDict = dict()
  totalCount = 0

  # load all the participants, initialize count = 0
  for i in m1['participants']:
    count = 0

    # go through all the messages
    for j in allMessages:
      # for each message, if sender name matches the participant name, increment count by 1
      for k in j['messages']:
        if k['sender_name'] == i['name']:
          if 'content' in k:
            if word in k['content']:
              count = count + 1
              totalCount = totalCount + 1
    #print(i['name'], count)
    #print(i['name'], count)
    # add the name and respective count value to the unsorted dictionary
    tempName = i['name']
    unsortedDict[tempName] = count

    # sort the dictionary

  # sorts the dictionary by increasing messages
  sortedDict = dict(sorted(unsortedDict.items(), key = lambda item: item[1]))
  print("Total: ", totalCount)
  for keys, values in sortedDict.items():
    print(keys, values)

  return sortedDict

# for each person, counts how many times the teacup emoji was used
def teacupCounter():
  return wordCounter('\u00f0\u009f\u008d\u00b5')


# displays a bar graph
def printBarGraph(dictData):

  data = dictData
  names = list(data.keys())
  values = list(data.values())

  plt.figure(figsize = (15, 10))
  plt.barh(range(len(data)), values, tick_label = names)
  plt.xticks(rotation = 90)

  plt.show()


# displays a pie chart
def printPieChart(dictData):

  data = dictData
  names = list(data.keys())
  values = list(data.values())
  
  fig, ax = plt.subplots()
  ax.pie(values, labels = names, radius = 2, autopct = '%1.1f%%')

data2 = totalWordsSpoken()
printBarGraph(data2)
printPieChart(data2)

data = messageCounter()
printBarGraph(data)
printPieChart(data)